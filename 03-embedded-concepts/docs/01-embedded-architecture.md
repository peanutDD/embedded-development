# 嵌入式系统架构

## 概述

嵌入式系统是专门为特定应用设计的计算机系统，通常集成在更大的设备中。与通用计算机不同，嵌入式系统具有实时性、资源受限、功耗敏感等特点。

## 嵌入式系统的基本组成

### 1. 硬件层 (Hardware Layer)

#### 微控制器 (MCU)
- **处理器核心**: ARM Cortex-M、RISC-V、AVR 等
- **内存**: Flash（程序存储）、SRAM（数据存储）、EEPROM（非易失性数据）
- **时钟系统**: 内部振荡器、外部晶振、PLL 倍频器

#### 外设接口
- **GPIO**: 通用输入输出端口
- **通信接口**: UART、SPI、I2C、CAN、USB 等
- **模拟接口**: ADC、DAC、比较器
- **定时器**: 基本定时器、高级定时器、看门狗定时器

#### 电源管理
- **电源域**: 核心电源、I/O 电源、模拟电源
- **低功耗模式**: 睡眠、深度睡眠、停机模式
- **电源监控**: 欠压检测、过压保护

### 2. 软件层 (Software Layer)

#### 底层驱动 (HAL - Hardware Abstraction Layer)
```
应用层 (Application Layer)
    ↓
中间件层 (Middleware Layer)
    ↓
操作系统层 (OS Layer) - 可选
    ↓
硬件抽象层 (HAL Layer)
    ↓
硬件层 (Hardware Layer)
```

#### 实时操作系统 (RTOS) - 可选
- **任务调度**: 抢占式、协作式、时间片轮转
- **同步机制**: 信号量、互斥锁、消息队列
- **内存管理**: 静态分配、动态分配、内存池

## 嵌入式系统特点

### 1. 实时性要求
- **硬实时**: 必须在规定时间内完成，如安全控制系统
- **软实时**: 尽量在规定时间内完成，如多媒体系统

### 2. 资源受限
- **内存限制**: 通常只有几KB到几MB的RAM
- **存储限制**: Flash 容量有限，需要优化代码大小
- **计算能力**: 处理器频率相对较低

### 3. 功耗敏感
- **电池供电**: 需要优化功耗延长电池寿命
- **热管理**: 控制发热量，避免过热

### 4. 可靠性要求
- **故障处理**: 看门狗、异常处理、错误恢复
- **环境适应**: 温度、湿度、振动、电磁干扰

## 内存映射

### 典型的 ARM Cortex-M 内存映射

```
0xFFFFFFFF ┌─────────────────┐
           │   系统区域       │
0xE0000000 ├─────────────────┤
           │   外设区域       │
0x40000000 ├─────────────────┤
           │   SRAM 区域      │
0x20000000 ├─────────────────┤
           │   Flash 区域     │
0x08000000 ├─────────────────┤
           │   系统内存       │
0x00000000 └─────────────────┘
```

### 内存区域详解

1. **Flash 区域 (0x08000000 - 0x0807FFFF)**
   - 存储程序代码和常量数据
   - 只读，掉电不丢失
   - 可以通过编程接口擦写

2. **SRAM 区域 (0x20000000 - 0x20004FFF)**
   - 存储变量和运行时数据
   - 可读写，掉电丢失
   - 访问速度快

3. **外设区域 (0x40000000 - 0x5FFFFFFF)**
   - 外设寄存器映射
   - 通过内存映射方式访问外设

## 启动流程

### 1. 复位向量
```rust
// 复位向量表（位于 Flash 起始地址）
#[link_section = ".vector_table.reset_vector"]
#[no_mangle]
pub static RESET_VECTOR: unsafe extern "C" fn() -> ! = Reset;
```

### 2. 启动序列
1. **硬件复位**: 系统上电或复位信号
2. **加载栈指针**: 从向量表加载初始栈指针
3. **跳转到复位处理程序**: 执行 Reset Handler
4. **系统初始化**: 时钟配置、内存初始化
5. **跳转到主程序**: 进入 main 函数

### 3. 时钟系统配置
```rust
// 时钟配置示例
fn configure_clocks() {
    // 启用外部高速晶振 (HSE)
    rcc.cr.modify(|_, w| w.hseon().set_bit());
    
    // 等待 HSE 稳定
    while rcc.cr.read().hserdy().bit_is_clear() {}
    
    // 配置 PLL
    rcc.pllcfgr.modify(|_, w| {
        w.pllsrc().hse()
         .pllm().bits(8)
         .plln().bits(336)
         .pllp().div4()
    });
    
    // 启用 PLL
    rcc.cr.modify(|_, w| w.pllon().set_bit());
    
    // 等待 PLL 锁定
    while rcc.cr.read().pllrdy().bit_is_clear() {}
    
    // 切换系统时钟到 PLL
    rcc.cfgr.modify(|_, w| w.sw().pll());
}
```

## 中断系统

### 1. 中断向量表
```rust
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static INTERRUPTS: [unsafe extern "C" fn(); 240] = [
    Timer2,        // TIM2 中断
    Timer3,        // TIM3 中断
    Timer4,        // TIM4 中断
    // ... 更多中断向量
];
```

### 2. 中断优先级
- **抢占优先级**: 高优先级中断可以打断低优先级中断
- **子优先级**: 同抢占优先级下的排队顺序

### 3. 中断处理流程
1. **中断请求**: 外设产生中断信号
2. **中断响应**: CPU 保存现场，跳转到中断服务程序
3. **中断处理**: 执行中断服务程序
4. **中断返回**: 恢复现场，返回被中断的程序

## 调试接口

### 1. SWD (Serial Wire Debug)
- **SWDIO**: 数据线
- **SWCLK**: 时钟线
- **SWO**: 跟踪输出（可选）

### 2. JTAG
- **TDI**: 测试数据输入
- **TDO**: 测试数据输出
- **TCK**: 测试时钟
- **TMS**: 测试模式选择

### 3. 调试功能
- **断点**: 硬件断点、软件断点
- **单步执行**: 指令级、源码级
- **内存查看**: 实时查看内存和寄存器
- **跟踪**: ITM、ETM 跟踪

## 总结

嵌入式系统架构是一个复杂的主题，涉及硬件和软件的紧密结合。理解这些基本概念对于嵌入式开发至关重要：

1. **硬件架构**: 了解微控制器的内部结构
2. **内存映射**: 掌握内存布局和访问方式
3. **启动流程**: 理解系统从复位到运行的过程
4. **中断系统**: 掌握中断机制和处理方法
5. **调试接口**: 熟悉调试工具和方法

这些知识为后续的外设编程和系统设计奠定了坚实的基础。